#version 450

#include "pbr_util.glsl"

#define NUM_SAMPLES 1024u

layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D t_output;

float GDFG(float NoV, float NoL, float a) {
    float a2 = a * a;
    float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
    float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
    return (2 * NoL) / (GGXV + GGXL);
}

vec2 IntegrateBRDF(float NdotV, float roughness)
{
    // Normal always points along z-axis for the 2D lookup
    const vec3 N = vec3(0.0, 0.0, 1.0);
    vec3 V = vec3(0.f);
    V.x = sqrt(1.0f - NdotV * NdotV);
    V.z = NdotV;

    vec2 lut = vec2(0.f);
    for(uint i = 0u; i < NUM_SAMPLES; i++)
    {
        vec2 Xi = Hammersley2D(i, NUM_SAMPLES);
        vec3 H = ImportanceSample_GGX(Xi, roughness, N);
        vec3 L = 2.0 * dot(V, H) * H - V;

        float VdotH = clamp(dot(V, H), 0.f, 1.f);
        float NdotL = clamp(L.z, 0.f, 1.f);
        float NdotH = clamp(H.z, 0.f, 1.f); // Filpped?

        if (NdotL > 0.0f)
        {
            float G = GDFG(NdotV, NdotL, roughness);
            float Gv = G * VdotH / NdotH;
            float Fc = pow(1 - VdotH, 5.0f);
            lut.x += Gv * (1 - Fc);
            lut.y += Gv * Fc;
        }
    }

    return lut / NUM_SAMPLES;
}

void main()
{
    const ivec2 resolution = imageSize(t_output);
    const vec2 uv = (vec2(gl_GlobalInvocationID.xy + 0.5f) / resolution);

    imageStore(t_output, ivec2(gl_GlobalInvocationID), vec4(IntegrateBRDF(uv.x, 1.0 - uv.y), 0, 1.f));
}
