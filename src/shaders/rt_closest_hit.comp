#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#pragma shader_stage(closest)

layout(location = 0) rayPayloadInNV vec3 hitValue;
hitAttributeNV vec3 attribs;

struct Vertex
{
	float x;
	float y;
	float z;

	float u;
	float v;
	
	float nx;
	float ny;
	float nz;

	float tx;
	float ty;
	float tz;

	float bx;
	float by;
	float bz;
};

struct ReadableVertex
{
	vec3 pos;
	vec2 uv;
	vec3 normal;
	vec3 tangent;
	vec3 bitangent;
};

struct RaytracingOffset
{   
	uint vertex_offset;
	uint idx_offset;
};

struct Light
{
    vec3 m_pos;
    float m_radius;

	vec3 m_dir;
	float m_inner_angle;

    vec3 m_color;
    uint m_type;

	float m_outer_angle;
	vec3 m_padding;
};

layout(set = 3, binding = 3) uniform UniformBufferLightObject {
    Light lights[50];
} lights;

layout(set = 4, binding = 4) buffer VertexBufferObj {
	Vertex vertices[];
} vb;

layout(set = 5, binding = 5) buffer IndexBufferObj {
	uint indices[];
} ib;

layout(set = 6, binding = 6) buffer UniformBufferOffsetObject
{ 
    RaytracingOffset offsets[];
} offsets;

ReadableVertex VertexToReadable(Vertex vertex)
{
	ReadableVertex retval;
	retval.pos = vec3(vertex.x, vertex.y, vertex.z);
	retval.uv = vec2(vertex.u, vertex.v);
	retval.normal = vec3(vertex.nx, vertex.ny, vertex.nz);
	retval.tangent = vec3(vertex.tx, vertex.ty, vertex.tz);
	retval.bitangent = vec3(vertex.bx, vertex.by, vertex.bz);

	return retval;
}

vec3 HitAttribute(vec3 a, vec3 b, vec3 c, vec3 bary)
{
	vec3 vertexAttribute[3];
	vertexAttribute[0] = a;
	vertexAttribute[1] = b;
	vertexAttribute[2] = c;

	return vertexAttribute[0] +
		bary.x * (vertexAttribute[1] - vertexAttribute[0]) +
		bary.y * (vertexAttribute[2] - vertexAttribute[0]);
}

vec3 HitWorldPosition()
{
	return gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
}

void main()
{
	RaytracingOffset offset = offsets.offsets[gl_InstanceCustomIndexNV];
	const uint vertex_offset = offset.vertex_offset / 56;
	const uint index_offset = offset.idx_offset / 4;

	const uint triangle_stride = 3;
	uint base_idx = gl_PrimitiveID * triangle_stride;
	base_idx += index_offset;

	vec3 world_pos = HitWorldPosition();
	vec3 view_pos = gl_WorldRayOriginNV;

	uvec3 indices = uvec3(ib.indices[base_idx+0], ib.indices[base_idx+1], ib.indices[base_idx+2]);
	indices += uvec3(vertex_offset, vertex_offset, vertex_offset); // offset the start

	const ReadableVertex v0 = VertexToReadable(vb.vertices[indices.x]);
	const ReadableVertex v1 = VertexToReadable(vb.vertices[indices.y]);
	const ReadableVertex v2 = VertexToReadable(vb.vertices[indices.z]);

	const vec3 normal = normalize(HitAttribute(v0.normal, v1.normal, v2.normal, attribs));
	const vec3 N = normalize(gl_ObjectToWorldNV * vec4(normal, 0));

	uint num_lights = 1; //Light count is stored in 30 upper-bits of first light
    vec3 lighting = vec3(0);
    for (uint i = 0; i < num_lights; i++)
    {
        const vec3 light_color = lights.lights[i].m_color;
        const vec3 light_pos = lights.lights[i].m_pos;
		
		float ambient_strength = 0.1;
		vec3 ambient = ambient_strength * vec3(1);

		vec3 light_dir = normalize(light_pos - world_pos);
		float diff = max(dot(N, light_dir), 0.0);
		vec3 diffuse = diff * light_color;

		float specularStrength = 0.5;
		vec3 V = normalize(view_pos - world_pos);
		vec3 reflectDir = reflect(-light_dir, N);  
		float spec = pow(max(dot(V, reflectDir), 0.0), 4);
		vec3 specular = specularStrength * spec * light_color;

		lighting += (ambient + diffuse + specular) * 1;
	}

	hitValue = lighting;
}
