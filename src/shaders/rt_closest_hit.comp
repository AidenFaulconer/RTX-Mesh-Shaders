#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#pragma shader_stage(closest)

#define POINT_LIGHT 0
#define DIRECTIONAL_LIGHT 1
#define SPOT_LIGHT 2

#define SCATTER
#include "pbr+_util.glsl"

layout(location = 0) rayPayloadInNV vec3 hitValue;
hitAttributeNV vec3 attribs;

struct Vertex
{
	float x;
	float y;
	float z;

	float u;
	float v;
	
	float nx;
	float ny;
	float nz;

	float tx;
	float ty;
	float tz;

	float bx;
	float by;
	float bz;
};

struct ReadableVertex
{
	vec3 pos;
	vec2 uv;
	vec3 normal;
	vec3 tangent;
	vec3 bitangent;
};

struct RaytracingOffset
{   
	uint vertex_offset;
	uint idx_offset;
};

struct RaytracingMaterial
{   
	uint albedo_texture;
	uint normal_texture;
	uint roughness_texture;
};

struct Light
{
    vec3 m_pos;
    float m_radius;

	vec3 m_dir;
	float m_inner_angle;

    vec3 m_color;
    uint m_type;

	float m_outer_angle;
	vec3 m_padding;
};

layout(set = 3, binding = 3) uniform UniformBufferLightObject {
    Light lights[50];
} lights;

layout(set = 4, binding = 4) buffer VertexBufferObj {
	Vertex vertices[];
} vb;

layout(set = 5, binding = 5) buffer IndexBufferObj {
	uint indices[];
} ib;

layout(set = 6, binding = 6) buffer UniformBufferOffsetObject
{ 
    RaytracingOffset offsets[];
} offsets;

layout(set = 7, binding = 7) buffer UniformBufferMaterialObject
{ 
    RaytracingMaterial materials[];
} materials;

layout(set = 8, binding = 8) uniform sampler2D ts_textures[500];

layout(set = 10, binding = 10) uniform sampler2D t_brdf_lut;

ReadableVertex VertexToReadable(Vertex vertex)
{
	ReadableVertex retval;
	retval.pos = vec3(vertex.x, vertex.y, vertex.z);
	retval.uv = vec2(vertex.u, vertex.v);
	retval.normal = vec3(vertex.nx, vertex.ny, vertex.nz);
	retval.tangent = vec3(vertex.tx, vertex.ty, vertex.tz);
	retval.bitangent = vec3(vertex.bx, vertex.by, vertex.bz);

	return retval;
}

vec3 HitAttribute(vec3 a, vec3 b, vec3 c, vec3 bary)
{
	vec3 vertexAttribute[3];
	vertexAttribute[0] = a;
	vertexAttribute[1] = b;
	vertexAttribute[2] = c;

	return vertexAttribute[0] +
		bary.x * (vertexAttribute[1] - vertexAttribute[0]) +
		bary.y * (vertexAttribute[2] - vertexAttribute[0]);
}

vec3 HitWorldPosition()
{
	return gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
}

void main()
{
	RaytracingOffset offset = offsets.offsets[gl_InstanceCustomIndexNV];
	const uint vertex_offset = offset.vertex_offset / 56;
	const uint index_offset = offset.idx_offset / 4;

	const uint triangle_stride = 3;
	uint base_idx = gl_PrimitiveID * triangle_stride;
	base_idx += index_offset;

	vec3 world_pos = HitWorldPosition();
	vec3 view_pos = gl_WorldRayOriginNV;

	uvec3 indices = uvec3(ib.indices[base_idx+0], ib.indices[base_idx+1], ib.indices[base_idx+2]);
	indices += uvec3(vertex_offset, vertex_offset, vertex_offset); // offset the start

	const ReadableVertex v0 = VertexToReadable(vb.vertices[indices.x]);
	const ReadableVertex v1 = VertexToReadable(vb.vertices[indices.y]);
	const ReadableVertex v2 = VertexToReadable(vb.vertices[indices.z]);

	const vec3 normal = normalize(HitAttribute(v0.normal, v1.normal, v2.normal, attribs));
	const vec3 tangent = normalize(HitAttribute(v0.tangent, v1.tangent, v2.tangent, attribs));
	const vec3 bitangent = normalize(HitAttribute(v0.bitangent, v1.bitangent, v2.bitangent, attribs));
	vec2 uv = HitAttribute(vec3(v0.uv, 0), vec3(v1.uv, 0), vec3(v2.uv, 0), attribs).xy;
	uv.y = 1.0f - uv.y;

	const vec3 N = normalize(gl_ObjectToWorldNV * vec4(normal, 0));
	const vec3 geometric_normal = N;

	// Raytracing Material
	RaytracingMaterial material = materials.materials[gl_InstanceCustomIndexNV];

	vec3 albedo = texture(ts_textures[material.albedo_texture], uv).rgb;
	float thickness = 0.1;
	float metallic = 0;
	float roughness = 1;
	float anisotropy = 0;
	vec3 anisotropic_t = vec3(0);
	vec3 anisotropic_b = vec3(0);
	float clear_coat = 0;
	float cc_roughness = clamp(0, MIN_PERCEPTUAL_ROUGHNESS, 1.0);;
	float reflectivity = 0.5;
	vec3 subsurface_color = vec3(143 / 255.f, 17 / 255.f, 0);
	float subsurface_power = 0;

	vec3 V = normalize(gl_WorldRayOriginNV - world_pos);

	vec3 diffuse_color = ComputeDiffuseColor(albedo, metallic);
	
	vec3 F0;
    if (reflectivity > -1)
    {
        float reflectance = ComputeDielectricF0(reflectivity); // TODO: proper material reflectance
        F0 = ComputeF0(albedo, metallic, reflectance);
    }
    else
    {
        F0 = mix(vec3(0.04), albedo, 1 - metallic);
    }
	float NdotV = max(dot(N, V), MIN_N_DOT_V);
	vec2 dfg = texture(t_brdf_lut, vec2(NdotV, roughness)).gr; // lut
	vec3 energy_compensation = 1.0 + F0 * (1.0 / dfg.y - 1.0);

	uint num_lights = 1; //Light count is stored in 30 upper-bits of first light
    vec3 lighting = vec3(0);
    for (uint i = 0; i < num_lights; i++)
    {
		const vec3 light_color = lights.lights[i].m_color;
        const vec3 light_pos = lights.lights[i].m_pos;
		const vec3 light_dir = lights.lights[i].m_dir;
		const uint type = lights.lights[i].m_type & 3;
		const float inner_angle = lights.lights[i].m_inner_angle;
		const float outer_angle = lights.lights[i].m_outer_angle;

		const vec3 pos_to_light = light_pos - world_pos;
        vec3 L = normalize(pos_to_light);

		float sqr_falloff = lights.lights[i].m_radius * lights.lights[i].m_radius;
		float sqr_inv_radius = sqr_falloff > 0.0f ? (1 / sqr_falloff) : 0;

		float attenuation = GetDistanceAttenuation(pos_to_light, sqr_inv_radius);
		if (type == DIRECTIONAL_LIGHT)
		{
			attenuation = 1;
			L = -light_dir;
		}
		else if (type == SPOT_LIGHT)
		{
			attenuation *= GetAngleAttenuation(light_dir, L, inner_angle, outer_angle);
		}

        float NdotL = clamp(dot(N, L), 0.0, 1.0); // TODO: Duplicate ndotl

#ifdef SCATTER
		if (thickness < 1)
		{
			lighting += SS_BRDF(L, V, N, geometric_normal, metallic, roughness, diffuse_color, light_color, F0, energy_compensation, attenuation, 1.0f, thickness, subsurface_color, subsurface_power);
		}
		else
		{
			if (NdotL > 0.0)
			{
				lighting += BRDF(L, V, N, geometric_normal, metallic, roughness, diffuse_color, light_color, F0, energy_compensation, attenuation, 1.0f, anisotropy, anisotropic_t, anisotropic_b, clear_coat, cc_roughness);
			}
		}
#else
		if (NdotL > 0.0)
		{
			lighting += BRDF(L, V, N, geometric_normal, metallic, roughness, diffuse_color, light_color, F0, energy_compensation, attenuation, 1.0f, anisotropy, anisotropic_t, anisotropic_b, clear_coat, cc_roughness);
		}
#endif
	}

	hitValue = lighting;
}
