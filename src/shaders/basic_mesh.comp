#version 450
#pragma shader_stage(mesh)

#define USE_NATIVE   1
#extension GL_NV_mesh_shader : enable

#define GROUP_SIZE 32
#define NVMESHLET_VERTEX_COUNT      64
#define NVMESHLET_PRIMITIVE_COUNT   126	

#define NVMSH_INDEX_BITS      8
#define NVMSH_PACKED4X8_GET(packed, idx)   (((packed) >> (NVMSH_INDEX_BITS * (idx))) & 255)

layout(local_size_x=GROUP_SIZE) in;
layout(max_vertices=NVMESHLET_VERTEX_COUNT, max_primitives=NVMESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;

layout(location = 0) out vec2 g_uv[];
layout(location = 1) out vec3 g_normal[];
layout(location = 2) out vec3 g_frag_pos[];
layout(location = 3) out vec3 g_tangent[];
layout(location = 4) out vec3 g_bitangent[];

struct Vertex
{
	vec3 m_pos;
	vec2 m_uv;
	vec3 m_normal;
	vec3 m_tangent;
	vec3 m_bitangent;
};

layout(set = 1, binding = 1) uniform UniformBufferObject {
    mat4 model;
} ubo;

layout(set = 0, binding = 0) uniform UniformBufferCameraObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 4, binding = 4) buffer VertexBufferObj {
	Vertex vertices[24];
} vb;

layout(set = 5, binding = 5) buffer IndexBufferObj {
	uint indices[36];
} ib;

vec3 positions[24];

void main()
{
	positions[0] = vec3(-0.5, -0.5, -0.5);
	positions[1] = vec3(0.5, -0.5, -0.5);
	positions[2] = vec3(-0.5, 0.5, -0.5);
	positions[3] = vec3(0.5, 0.5, -0.5);
	positions[6] = vec3(-0.5, 0.5, 0.5);

	int meshlet_id = int(gl_WorkGroupID.x);

	if (gl_LocalInvocationID.x == 0) {
    	gl_PrimitiveCountNV = 36 / 3;
		gl_PrimitiveCountNV = 2;
  	}
/*	gl_PrimitiveIndicesNV[0] = 0;
	gl_PrimitiveIndicesNV[1] = 1;
	gl_PrimitiveIndicesNV[2] = 2;

	g_frag_pos[0] = vec3(1, 0, 0);
	g_frag_pos[1] = vec3(0, 1, 0);
	g_frag_pos[2] = vec3(0, 0, 1);

	gl_MeshVerticesNV[0].gl_Position = vec4(1, -1, 0, 1);
	gl_MeshVerticesNV[1].gl_Position = vec4(-1, 1, 0, 1);
	gl_MeshVerticesNV[2].gl_Position = vec4(-1, -1, 1, 1);*/

	// indices
	for (int i = 0; i < 6; i++)
	{
		uint idx = ib.indices[i];
		gl_PrimitiveIndicesNV[i] = idx;

		/*Vertex vertex = vb.vertices[idx];
		vec3 pos = vertex.m_pos;
		vec2 uv = vertex.m_uv;
		vec3 normal = vertex.m_normal;
		vec3 tangent = vertex.m_tangent;
		vec3 bitangent = vertex.m_bitangent;

		g_frag_pos[idx] = vec3(ubo.model * vec4(pos, 1.0));
		g_normal[idx] = normalize(ubo.model * vec4(normal, 0)).xyz;
		g_tangent[idx] = normalize(ubo.model * vec4(tangent, 0)).xyz;
		g_bitangent[idx] = normalize(ubo.model * vec4(bitangent, 0)).xyz;
		g_uv[idx] = vertex.m_uv;

		gl_MeshVerticesNV[idx].gl_Position = camera.proj * camera.view * ubo.model * vec4(pos, 1.0);
		gl_MeshVerticesNV[idx].gl_ClipDistance[0] = 0;
		gl_MeshVerticesNV[idx].gl_ClipDistance[1] = 0;
		gl_MeshVerticesNV[idx].gl_ClipDistance[2] = 0;*/
	}

	// vertices
	for (int i = 0; i < 24; i++)
	{
		Vertex vertex = vb.vertices[i];
		vec3 pos = vertex.m_pos;
		vec2 uv = vertex.m_uv;
		vec3 normal = vertex.m_normal;
		vec3 tangent = vertex.m_tangent;
		vec3 bitangent = vertex.m_bitangent;

		g_frag_pos[i] = vec3(ubo.model * vec4(pos, 1.0));
		g_normal[i] = normalize(ubo.model * vec4(normal, 0)).xyz;
		g_tangent[i] = normalize(ubo.model * vec4(tangent, 0)).xyz;
		g_bitangent[i] = normalize(ubo.model * vec4(bitangent, 0)).xyz;
		g_uv[i] = vertex.m_uv;

		gl_MeshVerticesNV[i].gl_Position = camera.proj * camera.view * ubo.model * vec4(pos, 1.0);
		gl_MeshVerticesNV[i].gl_ClipDistance[0] = 0;
		gl_MeshVerticesNV[i].gl_ClipDistance[1] = 0;
		gl_MeshVerticesNV[i].gl_ClipDistance[2] = 0;
	}
}
