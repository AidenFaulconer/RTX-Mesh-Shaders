#version 450
#pragma shader_stage(mesh)

#define USE_NATIVE   1
#extension GL_NV_mesh_shader : enable

#define GROUP_SIZE 32
#define NVMESHLET_VERTEX_COUNT      64
#define NVMESHLET_PRIMITIVE_COUNT   126	

#define NVMSH_INDEX_BITS      8
#define NVMSH_PACKED4X8_GET(packed, idx)   (((packed) >> (NVMSH_INDEX_BITS * (idx))) & 255)

layout(local_size_x=GROUP_SIZE) in;
layout(max_vertices=NVMESHLET_VERTEX_COUNT, max_primitives=NVMESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;

layout(location = 0) out vec2 g_uv[];
layout(location = 1) out vec3 g_normal[];
layout(location = 2) out vec3 g_frag_pos[];
layout(location = 3) out vec3 g_tangent[];
layout(location = 4) out vec3 g_bitangent[];

struct Vertex
{
	float x;
	float y;
	float z;

	float u;
	float v;
	
	float nx;
	float ny;
	float nz;

	float tx;
	float ty;
	float tz;

	float bx;
	float by;
	float bz;
};

layout(set = 1, binding = 1) uniform UniformBufferObject {
    mat4 model;
} ubo;

layout(set = 0, binding = 0) uniform UniformBufferCameraObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 4, binding = 4) buffer VertexBufferObj {
	Vertex vertices[];
} vb;

layout(set = 5, binding = 5) buffer IndexBufferObj {
	uint indices[36];
} ib;

void main()
{
	int meshlet_id = int(gl_WorkGroupID.x);

	gl_PrimitiveCountNV = 36 / 3;

	// primitives
	for (int i = 0; i < 36; i += 3)
	{
		gl_PrimitiveIndicesNV[i] = ib.indices[i];
		gl_PrimitiveIndicesNV[i+1] = ib.indices[i+1];
		gl_PrimitiveIndicesNV[i+2] = ib.indices[i+2];
	}

	// vertices
	for (int i = 0; i < 24; i++)
	{
		Vertex vertex = vb.vertices[i];
		vec3 pos = vec3(vertex.x, vertex.y, vertex.z);
		vec2 uv = vec2(vertex.u, vertex.v);
		vec3 normal = vec3(vertex.nx, vertex.ny, vertex.nz);
		vec3 tangent = vec3(vertex.tx, vertex.ty, vertex.tz);
		vec3 bitangent = vec3(vertex.bx, vertex.by, vertex.bz);

		g_frag_pos[i] = vec3(ubo.model * vec4(pos, 1.0));
		g_normal[i] = normalize(ubo.model * vec4(normal, 0)).xyz;
		g_tangent[i] = normalize(ubo.model * vec4(tangent, 0)).xyz;
		g_bitangent[i] = normalize(ubo.model * vec4(bitangent, 0)).xyz;
		g_uv[i] = uv;

		gl_MeshVerticesNV[i].gl_Position = camera.proj * camera.view * ubo.model * vec4(pos, 1.0);
	}
}
