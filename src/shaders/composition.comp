#version 450

#include "pbr_util.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 1, binding = 1, rgba8) uniform readonly image2D ts_gbuffers[3];
layout(set = 2, binding = 2, rgba8) uniform writeonly image2D t_output;
layout(set = 4, binding = 4) uniform samplerCube t_skybox;

layout(set = 0, binding = 0) uniform UniformBufferCameraObject {
    mat4 view;
    mat4 proj;
} camera;

mat4 perspective(float fovy, float aspect, float zNear, float zFar)
{
    float rad = fovy;
    float tanHalfFovy = tan(rad / 2.f);

    mat4 result = mat4(0);
    result[0][0] = 1.f / (aspect * tanHalfFovy);
    result[1][1] = 1.f / (tanHalfFovy);
    result[2][2] = - (zFar + zNear) / (zFar - zNear);
    result[2][3] = - 1.f;
    result[3][2] = - (2.f * zFar * zNear) / (zFar - zNear);
    return result;
}

mat4 look_at(vec3 eye, vec3 center, vec3 up)
{
    vec3 f = vec3(normalize(center - eye));
    vec3 s = vec3(normalize(cross(f, up)));
    vec3 u = vec3(cross(s, f));

    mat4 result = mat4(1);
    result[0][0] = s.x;
    result[1][0] = s.y;
    result[2][0] = s.z;
    result[0][1] = u.x;
    result[1][1] = u.y;
    result[2][1] = u.z;
    result[0][2] =-f.x;
    result[1][2] =-f.y;
    result[2][2] =-f.z;
    result[3][0] =-dot(s, eye);
    result[3][1] =-dot(u, eye);
    result[3][2] = dot(f, eye);

    return result;
}


struct Light
{
    vec3 m_pos;
    float m_radius;

    vec3 m_color;
    uint m_type;
};

layout(set = 3, binding = 3) uniform UniformBufferLightObject {
    Light lights[50];
} lights;

void main()
{
    const ivec2 resolution = imageSize(t_output);
    const vec2 uv = (vec2(gl_GlobalInvocationID.xy + 0.5f) / resolution);
    const ivec2 s_uv = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    // GBuffers
    const vec4 albedo_roughness = imageLoad(ts_gbuffers[0], s_uv);
    const vec4 normal_metallic = imageLoad(ts_gbuffers[1], s_uv);
    const vec4 world_pos_ao = imageLoad(ts_gbuffers[2], s_uv);

    const vec3 world_pos = world_pos_ao.xyz;
    const vec3 albedo = albedo_roughness.rgb;
    const vec3 N = normalize(normal_metallic.xyz);
    const float roughness = albedo_roughness.a;
    const float metallic = normal_metallic.a;
    const float ao = world_pos_ao.a;

    // Constants
    const float specular_strength = 0.5;
    const float irradiance = 0.1;
    const vec3 view_pos = vec3(0, 0, -2.5);

    vec3 V = normalize(view_pos - world_pos);
    vec3 R = reflect(-V, N);

    uint num_lights = 3; //Light count is stored in 30 upper-bits of first light

    vec3 lighting = vec3(0);
    for (uint i = 0; i < num_lights; i++)
    {
        const vec3 light_color = lights.lights[i].m_color;
        const vec3 light_pos = lights.lights[i].m_pos;

        vec3 L = normalize(light_pos - world_pos);
        lighting += BRDF(L, V, N, metallic, roughness, albedo, light_color);
    }

    vec3 diffuse = irradiance * albedo;
    vec3 F = F_SchlickRoughness(max(dot(N, V), 0.0), metallic, albedo, roughness);
    vec3 reflection = pow(texture(t_skybox, R).rgb, vec3(2.2));
    vec3 specular = reflection * (F);

    vec3 kD = 1.0 - F;
    kD *= 1.0 - metallic;
    vec3 color = (kD * diffuse + specular) + lighting;

    color *= ao;

    if (world_pos.z == 0)
    {
        const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy) + vec2(0.5);
        const vec2 inUV = pixelCenter/resolution;
        vec2 d = inUV;

        vec4 target = inverse(camera.proj) * vec4(d.x, d.y, 1, 1) ;
        vec4 direction = inverse(camera.view) * vec4(normalize(target.xyz), 0);

        color = pow(texture(t_skybox, direction.xyz).rgb, vec3(2.2));
    }

    imageStore(t_output, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}
